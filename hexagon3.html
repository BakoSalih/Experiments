<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lozenge tiling</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>

  <style>
	body {background-color: white;}
	.row {
  display: flex;
}

.column {
  flex: 50%;
  background-color: lightgray;
}

.input0 {
	padding: 5px
}
   </style>
</head>
<body>

<div class="row">
  <div class="column", id="simulation">
  	<div id="sim"></div>
  </div>
  <div class="column">
    <h2> Hexagon parameters </h2>
    <div id="inputA", class="input0"> A = </div>
  	<div id="inputB", class="input0"> B = </div>
  	<div id="inputC", class="input0"> C = </div>

    <button onclick="myFunction()">Generate</button>

    <h2> Regular hexagon </h2>
  	<div id="inputN", class="input0"> N = </div>

    <button onclick="regularHex()">Generate</button>

    <h2> Properties </h2>
    <button onclick="edges()">Edges</button>
    <button onclick="rotate()">Rotate</button>
    <h2> Generate </h2>
    <button onclick="regenerate()">Generate</button>
  </div>

</div>


<script type="text/javascript">
  var Ainput = document.createElement("INPUT");
  Ainput.setAttribute("type", "number");
  Ainput.setAttribute("value", 5);
  Ainput.setAttribute("id", "Abox");
  document.getElementById("inputA").appendChild(Ainput);

  var Binput = document.createElement("INPUT");
  Binput.setAttribute("type", "number");
  Binput.setAttribute("value", 5);
  Binput.setAttribute("id", "Bbox");
  document.getElementById("inputB").appendChild(Binput);

  var Cinput = document.createElement("INPUT");
  Cinput.setAttribute("type", "number");
  Cinput.setAttribute("value", 5);
  Cinput.setAttribute("id", "Cbox");
  document.getElementById("inputC").appendChild(Cinput);

  var Ninput = document.createElement("INPUT");
  Ninput.setAttribute("type", "number");
  Ninput.setAttribute("value", 5);
  Ninput.setAttribute("id", "Nbox");
  document.getElementById("inputN").appendChild(Ninput);
</script>

<script type="text/javascript">

let type = "WebGL"
if(!PIXI.utils.isWebGLSupported()){
  type = "canvas"
}
//Create a Pixi Application
let app = new PIXI.Application({
  width: 500,
  height: 500,
  antialias: true,
  transparent: true,
  resolution: 1
}
);

//Add the canvas that Pixi automatically created for you to the HTML document
//document.body.appendChild(app.view);
document.getElementById("sim").appendChild(app.view);

// get A,B,C from input
const A = document.getElementById("Abox").valueAsNumber;
const B = document.getElementById("Bbox").valueAsNumber;
const C = document.getElementById("Cbox").valueAsNumber;

// edges exist of not
app.stage.edgeExist = 1;

// create initial matching
let W = weight_hexagon([[1],[1]],1,A,B,C)
W = W_split(W);
let P = Reduction(W, W.im);
let M = Matching(P, W[0].length);

//load an image and run the `setup` function when it's done
const loader = new PIXI.Loader();
loader
.load(setup(A, B, C));
//.load(setup(A, B, C, M));

drawHexagon(A,B,C,M)

function regenerate() {
  //
  // let W = weight_hexagon([[1],[1]],1,a,b,c)
  // W = W_split(W);
  // let P = Reduction(W, W.im);
  const A = document.getElementById("Abox").valueAsNumber;
  const B = document.getElementById("Bbox").valueAsNumber;
  const C = document.getElementById("Cbox").valueAsNumber;

  let M = Matching(P, W[0].length);
  drawHexagon(A,B,C,M);
  // app.ticker.add((delta) => {
  //   d += delta
  //   if (Math.floor(d) % 50 == 0) {
  //   app.stage.removeChildren(0)
  //   let M = Matching(P);
  //   setup(3, 3, 3);
  //   }
  // });
}

function rotate() {
  let container = app.stage.children[0];
  console.log(container.rotation);
  if (container.rotation == 0) {
    container.rotation = Math.PI/6;
    container.x = 200;
    container.y = -100;
  } else {
    container.rotation = 0;
    container.x = 0;
    container.y = 0;
  }
}

function edges() {
  if (app.stage.edgeExist == 1) {
    app.stage.edgeExist = 0;
  } else {
    app.stage.edgeExist = 1;
  }

}

function myFunction() {
  //app.stage.removeChildren(0)
  // constants for the size of the hexagon
  const A = document.getElementById("Abox").valueAsNumber;
  const B = document.getElementById("Bbox").valueAsNumber;
  const C = document.getElementById("Cbox").valueAsNumber;

  app.stage.removeChildren(0);
  setup(A, B, C);

//  setup(A, B, C, M);
}

function regularHex() {
  app.stage.removeChildren(0)
  // constants for the size of the hexagon
  const N = document.getElementById("Nbox").valueAsNumber;

  // set A,B,C
  document.getElementById("Abox").setAttribute("value", N);
  document.getElementById("Bbox").setAttribute("value", N);
  document.getElementById("Cbox").setAttribute("value", N);

  app.stage.removeChildren(0);
  setup(N,N,N);
  //setup(N, N, N, M);
}


// This `setup` function will run when the image has loaded
// Paints the matching
function setup(a, b, c) {

	let container = new PIXI.Container();
	app.stage.addChild(container);

  // edge exist?
  const lineThickness = app.stage.edgeExist;

  const n = a + c;
  const m = b + c;

  // constants for the grid directions
  const u = [1,0];
  const v = [-1/2, Math.sqrt(3)/2];
  const w = [1/2, Math.sqrt(3)/2];


  // length of unit
  const r = 100/Math.max(Math.max(a,b),c);
  const x1 = r/4;
  const y1 = r* (Math.sqrt(3)/4 - 1/3);
  const width = 1/2 * r;
  const shift = 0;

  // app window size and padding
  const ycorner = app.screen.height;
  const padding = Math.sqrt(3)/2*r - (a+c)*r + app.screen.height/2;
  const xpadding = -r*a + app.screen.height/2;// + r*m;



app.stage.lozenges = [];
for (i=0; i<2*n-1; i++) {
  const row = new Array(2*m-1);
  app.stage.lozenges.push(row);
}

for (i = 0; i < 2*n-1; i++) {
  for (j = 0; j < 2*m-1; j++) {
    // current coordinate of hexagon center
    const x_cord = r*(j * u[0] + i * v[0] );
    const y_cord = r*(j * u[1] + i * v[1]);

    // transform up-down and add padding
    const x0 = x_cord + xpadding;
    const y0 = ycorner - y_cord - padding;

    // add lozenge to container and to lozenges for future access
    if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a)) {
      if (j % 2 == 0 && i % 2 == 0) {
        // (even,even) position lozenge
        let loz = createLozenge1(x0, y0, r, lineThickness);
        // don't display immediately
        loz.visible = false;
        // add to lozenges
        app.stage.lozenges[i][j] = loz;
        container.addChild(loz);
      } else if (j % 2 == 1 && i % 2 == 0) {
        // (even,odd) position lozenge
        let loz = createLozenge2(x0, y0, r, lineThickness);
        loz.visible = false;
        app.stage.lozenges[i][j] = loz;
        container.addChild(loz);
      } else if (j % 2 == 0 && i % 2 == 1) {
        // (odd,even) position lozenge
        let loz = createLozenge3(x0, y0, r, lineThickness);
        loz.visible = false;
        app.stage.lozenges[i][j] = loz;
        container.addChild(loz);
      } else {
        // (odd,even) position lozenge
        let empty = new PIXI.Graphics();
        empty.visible = false;
        app.stage.lozenges[i][j] = empty;
      }
    }
  }
}


  // for (i = 0; i < 2*n-1; i++) {
  //   for (j = 0; j < 2*m-1; j++) {
  //     // current coordinate of hexagon center
  //     const x_cord = r*(j * u[0] + i * v[0] );
  //     const y_cord = r*(j * u[1] + i * v[1]);
  //
  //     // transform up-down and add padding
  //     const x0 = x_cord + xpadding;
  //     const y0 = ycorner - y_cord - padding;
  //
  //     // add lozenge to container
  //     if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a) && M[i][j]) {
  //       if (j % 2 == 0 && i % 2 == 0) {
  //         // (even,even) position lozenge
  //         if (M[i][j]) {
  //         let loz = createLozenge1(x0, y0, r);
  //         container.addChild(loz);
  //         }
  //       } else if (j % 2 == 1 && i % 2 == 0) {
  //         // (even,odd) position lozenge
  //         if (M[i][j]) {
  //         let loz = createLozenge2(x0, y0, r);
  //         container.addChild(loz);
  //         }
  //       } else if (j % 2 == 0 && i % 2 == 1) {
  //         // (odd,even) position lozenge
  //         if (M[i][j]) {
  //         let loz = createLozenge3(x0, y0, r);
  //         container.addChild(loz);
  //         }
  //       }
  // }

  // } else if (i >= 2*a && j > i-2*a) {
  //   if (j % 2 == 0 && i % 2 == 0 ) {
  //     // (even,even)
  //     //color = 0x46c668;
  //     if (M[i][j]) {
  //     let loz = createLozenge1(x0, y0, r);
  //     container.addChild(loz);
  //     }
  //   } else if (j % 2 == 1 && i % 2 == 0) {
  //     // (even,odd)
  //     //color = 0xfc0606;
  //     if (M[i][j]) {
  //     let loz = createLozenge2(x0, y0, r);
  //     container.addChild(loz);
  //     }
  //   } else if (j % 2 == 0 && i % 2 == 1) {
  //     // (odd,even)
  //     //color = 0xfffa8a;
  //     if (M[i][j]) {
  //     let loz = createLozenge3(x0, y0, r);
  //     container.addChild(loz);
  //     }
  //   } else {
  //     //color = 0x0038ff;
  //   }
  // }

  // // all the vertices
  // let vertex = new PIXI.Graphics();
  // vertex.beginFill(0x000000);
  // vertex.drawCircle(x0, y0, 2);
  // vertex.endFill();
  // container.addChild(vertex);


  // create new matching
  W = weight_hexagon([[1],[1]],1,a,b,c)
  W = W_split(W);
  P = Reduction(W, W.im);
  M = Matching(P, W[0].length);

  // draw matching
  drawHexagon(a,b,c,M);

	app.ticker.add((delta) => {
			//container.rotation += 0.01* delta;
	});

}

function createTriangle(xPos, yPos, r, type)
{
  var triangle = new PIXI.Graphics();

  triangle.x = xPos;
  triangle.y = yPos;

  // draw triangle
  if (type == 1) {
    triangle.beginFill(0x1cff00, 1);
    triangle.lineStyle(0, 0x000000, 1);
    triangle.moveTo(-r/2 , r/3);
    triangle.lineTo(r/2 , r/3);
    triangle.lineTo(0, -Math.sqrt(3)/2 * r + r/3);
  } else {
    triangle.beginFill(0x052dfe, 1);
    triangle.lineStyle(0, 0x000000, 1);
    triangle.moveTo(-r/2 , -r/3);
    triangle.lineTo(r/2 , -r/3);
    triangle.lineTo(0, Math.sqrt(3)/2 * r - r/3);
  }
  triangle.endFill();


  triangle.interactive = true;
  triangle.buttonMode = true;

  return triangle
}

function createLozenge1(xPos, yPos, r, lineThickness = 1)
{
  var loz = new PIXI.Graphics();

  loz.x = xPos - r/2;
  loz.y = yPos + r*Math.sqrt(3)/2;
  loz.beginFill(0x1cff00, 1);
  loz.lineStyle(1/2, 0x000000, lineThickness);
  loz.moveTo(0, 0);
  loz.lineTo(2*r, 0);
  loz.lineTo(r, -r*Math.sqrt(3));
  loz.lineTo(-r, -r*Math.sqrt(3));
  loz.endFill();

  return loz
}

function createLozenge2(xPos, yPos, r, lineThickness = 1)
{
  var loz = new PIXI.Graphics();

  loz.x = xPos + r/2;
  loz.y = yPos + r*Math.sqrt(3)/2;

  loz.beginFill(0xfc0606, 1);
  loz.lineStyle(1/2, 0x000000, lineThickness);
  loz.moveTo(0, 0);
  loz.lineTo(r, -r*Math.sqrt(3));
  loz.lineTo(-r, -r*Math.sqrt(3));
  loz.lineTo(-2*r, 0);
  loz.lineTo(0,0);
  loz.endFill();

  return loz
}

function createLozenge3(xPos, yPos, r, lineThickness = 1)
{
  var loz = new PIXI.Graphics();

  loz.x = xPos;
  loz.y = yPos + r*Math.sqrt(3);

  loz.beginFill(0xfffa8a, 1);
  loz.lineStyle(1/2, 0x000000, lineThickness);
  loz.moveTo(0, 0);
  loz.lineTo(r, -r*Math.sqrt(3));
  loz.lineTo(0, -2*r*Math.sqrt(3));
  loz.lineTo(-r, -r*Math.sqrt(3));
  loz.lineTo(0, 0);
  loz.endFill();

  return loz
}

// updates the lozenges using matching matrix M
function drawHexagon(a,b,c,M) {
  const n = a+c;
  const m = b+c;

  for (i = 0; i < 2*n-1; i++) {
    for (j = 0; j < 2*m-1; j++) {
      // use Matching matrix M to make lozenges visible
      if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a)) {
        if (M[i][j])  {
          app.stage.lozenges[i][j].visible = true;
        } else {
          app.stage.lozenges[i][j].visible = false;
        }
      }
    }
  }

}



  function W_split(W) {
    const n = W.length;
    var W_im = [];
    for (i=0; i<n; i++) {
      W_im[i] = [];
      W_im[i].length = n;
      W_im[i].fill(0)
    }

    for (i=0; i<n; i++) {
       for (j=0; j<n; j++) {
           wempty = (W[i][j] == 0);
           W_im[i][j] = 0+wempty;
           W[i][j] = W[i][j] + wempty;
       }
    }

    W.im = W_im;

    return W
  }



  function Matching(P,n) {
    // create empty (n+2)x(n+2) matrix M. We pad by 1 to simplify algorithm
    // at corners. The padding is then stripped away at the end
    var M = [];
    for (i=0; i<n+2; i++) {
      M[i] = new Uint8Array(n+2);
      M[i].fill(false);
    }

    const m = n/2;
    var k = 0;
    for (i = 0; i<=m; i++) {
        // store 'active' cells that need to be filled in the creation step
        var Mcells = [];
        // the destruction step (+ tracking cells to fill)
        for (y=m-i+1; y<=m+i-1; y += 2) {
            for (x=m-i+1; x<=m+i-1; x += 2) {
                // k keeps track of which weight is associated with
                // edge (y,x) at any step. Note: k is not reset at loop end
                k = k+1;
                const nonzeros = M[x][y] + M[x+1][y] + M[x][y+1] + M[x+1][y+1];
                // save the locations mcells to fill in next step
                // note we can only have 0, 1 or 2 edges in each cell
                switch (nonzeros) {
                    case 1: // slide if only 1 edge
                        const temp = M[x][y];
                        M[x][y] = M[x+1][y+1];
                        M[x+1][y+1] = temp;

                        const temp2 = M[x+1][y];
                        M[x+1][y] = M[x][y+1];
                        M[x][y+1] = temp2;
                        break;
                    case 2: // destroy if 2 edges
                        M[x][y] = false;
                        M[x+1][y] = false;
                        M[x][y+1] = false;
                        M[x+1][y+1] = false;
                        // store active cell
                        Mcells.push([y,x,k]);
                        break;
                    case 0:
                        // store active cell
                        Mcells.push([y,x,k]);
                        break;
                  }
            }
        }

        // the creation step, fill using Mcells
        for (r=0; r<Mcells.length; r++) {
            // get location (y,x)
            const y = Mcells[r][0];
            const x = Mcells[r][1];
            // check if cells below/to the left have been filled
            // note: creation step depends on order of filling
            if (!(M[x-1][y] || M[x+2][y] || M[x][y-1] || M[x+1][y-1])) {
                // randomly assign according to weight calculated in P
                const bool = Math.random() < P[P.length-Mcells[r][2]];
                // create new edges
                if (bool) {
                    M[x][y] = true;
                    M[x+1][y+1] = true;
                } else {
                    M[x+1][y] = true;
                    M[x][y+1] = true;
                }
            }
        }

    }

    // Mnew array
    //const A = document.getElementById("Abox").valueAsNumber;
    //const B = document.getElementById("Bbox").valueAsNumber;
    //const C = document.getElementById("Cbox").valueAsNumber;

    // strip away the padding
    var Mnew = [];
    for (i=n; i>=1; i--) {
      var Mrow = [];
      for (j=1; j<=n; j++) {
        Mrow.push(M[i][j]);
      }
      Mnew.push(Mrow);
    }
    return Mnew;
  }



  function Reduction(W_real, W_im) {
    const n = W_real.length;
    const m = n/2;
    var P = [];

    for (i=0; i<=m-1; i++) {
      // iterate from lower, right corner up and to the left
      // this is to produce P in a sequence that
      // can be simply iterated over in the matching step
      // else Pm_11 ... Pm_nn | ... | P2_11 P2_21 P2_12 P2_22 | P1_11
      // instead of more easily Pm_11 ... Pm_nn | ... | P2_22 P2_12 P2_21 P2_11 | P1_11
      for (y=n-2*i-2; y>=0; y -= 2) {
        for (x=n-2*i-2; x>=0; x -= 2) {
          const R1 = W_real[x+i][y+i];
          const R2 = W_real[x+1+i][y+i];
          const R3 = W_real[x+i][y+1+i];
          const R4 = W_real[x+1+i][y+1+i];

          const I1 = W_im[x+i][y+i];
          const I2 = W_im[x+1+i][y+i];
          const I3 = W_im[x+i][y+1+i];
          const I4 = W_im[x+1+i][y+1+i];

          var b = I1 + I4;
          const b23 = I2 + I3;
          var D = 1;
          if (b23 > b) {
            D = R1 * R4;
            P.push(1);
          } else if (b == b23) {
            D = R1 * R4 + R2 * R3;
            P.push(R1 * R4 / D);
          } else {
            b = b23;
            D = R2 * R3;
            P.push(0);
          }

          W_im[x+i][y+i] = I4 - b;
          W_im[x+1+i][y+i] = I3 - b;
          W_im[x+i][y+1+i] = I2 - b;
          W_im[x+1+i][y+1+i] = I1 - b;

          W_real[x+i][y+i] = R4 / D;
          W_real[x+1+i][y+i] = R3 / D;
          W_real[x+i][y+1+i] = R2 / D;
          W_real[x+1+i][y+1+i] = R1 / D;
        }
      }
    }
    return P;
  }


  function weight_hexagon(w,n,a,b,c) {

  const A = n*a;
  const B = n*b;
  const C = n*c;

  // make zero-filled array W
  const N = 2*(A+B+C-1);
  var W = [];
  for (i=0; i<N; i++) {
    W[i] = [];
    W[i].length = N;
    W[i].fill(0)
  }

  // get dimensions
  const Ly = w.length;
  const Lx = w[0].length;

  // populate W
  for (x = 0; x <N; x++) {
    for (y = 0; y<N; y++) {
        //inside the hexagon
        if (isinhexagon(x,y)) {
          // if x is even,
          if (x % 2 == 0) {
            // check if correct
            const k = x/2
            W[N-1-y][x] = w[Ly - 1 - (y % Ly)][k % Lx];
          } else {
            if (y % 2 == 0) {
                W[N-1-y][x] = 1;
            }
          }
        } else if (isinUpRightCorner(x,y) && isThereNoNeighbour(x,y)) {
          W[N-1-y][x] = 1;
        } else { // outside the hexagon
          if (isThereNoNeighbour(x,y) && ((y+x) % 2 == 1)) {
              W[N-1-y][x] = 1;
          }
        }
    }
  }

  // find neighbour
  function isThereNoNeighbour(x, y) {
    //N = W.length;
    var boolean = false;
    const x_ind = N-1-y;

    if (x == 0 && y == 0) {
      boolean = true;
    } else if (x == 0 && y > 0) {
      if (W[x_ind+1][x] == 0) {
          boolean = true;
      } else {
          boolean = false;
      }
    } else if (x > 0 && y == 0) {
      if ((x+y) % 2 == 1) {
        if (W[x_ind][x-1] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      } else {
        if (W[x_ind][x-1] == 0 && W[x_ind-1][x-1] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      }
    } else if (x > 0 && y == N-1) {
      if ((x+y) % 2 == 1) {
        if (W[x_ind][x-1] == 0 && W[x_ind+1][x-1] == 0 && W[x_ind+1][x] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      } else {
        if (W[x_ind][x-1] == 0 && W[x_ind+1][x] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      }
    } else if (x > 0 && y > 0 && y < N-1) {
      if ((x+y) % 2 == 1) {
        if (W[x_ind][x-1] == 0 && W[x_ind+1][x-1] == 0 && W[x_ind+1][x] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      } else {
        if (W[x_ind][x-1] == 0 && W[x_ind-1][x-1] == 0 && W[x_ind+1][x] == 0) {
            boolean = true;
        } else {
            boolean = false;
        }
      }
    }
    return boolean
  }


  // isinhexagon(x2,y2) return true if (x2,y2) is inside the hexagon.
  // return false otherwise
  function isinhexagon(x2,y2) {
      var boolean = false;

      if (x2 < 2*Math.min(B,C)) {
          boolean = (y2 >= 0 && y2 < 2*A+x2);
      } else if (x2 >= 2*C && x2 < 2*B) {
          boolean = (y2 >= 0 && y2 < 2*(A+C)-1);
      } else if (x2 >= 2*B && x2 < 2*C) {
          boolean = (y2 >= x2-2*B+1 && y2 < 2*A+x2);
      } else if (x2 >= 2*Math.max(B,C) && x2 < 2*(B+C)-1) {
          boolean = (y2 >= x2-2*B+1 && y2 < 2*(A+C)-1);
      }

      return boolean
  }

  // isinUpRightCorner(x3,y3) return true if (x3,y3) is in the top right
  // corner outside the hexagon.
  // return false otherwise
  function isinUpRightCorner(x3,y3) {
      return (x3 >= 2*(B+C)-1 && y3 >= 2*(A+C)-1);
  }



  return W
  }




</script>

</body>
</html>
