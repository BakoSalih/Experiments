<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lozenge tiling</title>

  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>

</head>
<body>

<!-- tooltips -->
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<div class="row">
  <div>
  <h1>Lozenge tilings</h1>
  </div>

  <div class="column left" id="options1">
    <div>
      <h2> Hexagon Parameters </h2>
      <h3> Lozenges per side: A*N, B*N, C*N</h3>

        <div>
      <div id="inputN" class="input0">
        <p>N</p>
        <input type="number" value="80" id="Nbox" name="N" class="numinput">
      </div>
      <div id="inputA" class="input0">
      <p>A</p>
      <input type="number" value="1", step="0.1" min="1" id="Abox" name="A" class="numinput">
        <p>B</p>
        <input type="number" value="1", step="0.1" min="1"  id="Bbox" name="B" class="numinput">
        <p>C</p>
        <input type="number" value="1", step="0.1" min="1"  id="Cbox" name="C" class="numinput">
      </div>

    </div>
      <div id="inputW">
        <select id="wtype" onchange="hidewform()">
        <option value="uniform" selected="selected">Uniform</option>
        <option value="qvolume">q-Volume</option>
        <option value="periodic1x2">1x2 Periodic</option>
        <option value="periodic2x2">2x2 Periodic</option>
        <option value="periodic2x3">2x3 Periodic</option>
        <!-- <option value="qracah">real q-Racah</option> -->
        <option value="racah">Racah</option>
        <option value="custom">Custom</option>
        </select>
        <input type="number" value="0.1" step="0.1" id="cweight" name="Wweight"
               class="numinput" style="display:none"/>
        <div id="rows" style="display:none;">
          <br>
        row
        <input type="number" value="1", step="1" min="1"  id="rownums"
        onchange="addrow()" name="rownums" class="numinput" style="display:none">
        col
        <input type="number" value="1", step="1" min="1"  id="kappa" style="display:none;width:50px;" />
        </div>
      </div>

      <h2> Generate Tilings</h2>
      <div>
      <button id="redraw", onclick="reDraw()">Redraw</button>
      <!-- <h3> Reweight (same hexagon dims)</h3>
      <button id="reweight" onclick="reweight()">Reweight</button> -->
      <!-- </div> -->

      <h3> Rematch (same weight) </h3>
  	  <!-- <div> -->
      <button id="rematch" onclick="refresh()">Rematch</button>
      </div>
  	  <div>
      <h3> Generate a large number of <br> tilings and display average </h3>
  	    <button id="animatehex" onclick="animatehex()">Animate</button>
          <button id="pause" onclick="pause()">Stop</button>
      </div>
      <div>
        <!-- <h3> This colors each lozenge by <br> its exact probability of occuring</h3> -->
        <button id="probcolor" onclick="prob_color()">Probability color</button>
      </div>
    </div>

    <div class="collapsible">
      <h2> Display options </h2>
    </div>
    <div class="content">
      <h2> Color options </h2>
      <h3> Pick lozenge colors </h3>
      <svg width="100" height="20" style="padding:0px;margin:4px;" >
      <rect x="0" y="0" width="20" height="20" class="colbox" id="colorbox1" onclick="colorpick(this)" style="fill:#1cff00;" />
      <rect x="30" y="0" width="20" height="20" class="colbox"id="colorbox2" onclick="colorpick(this)" style="fill:#fc0606;" />
      <rect x="60" y="0" width="20" height="20" class="colbox" id="colorbox3" onclick="colorpick(this)" style="fill:#0555db;" />
      </svg>
      <br>
        <button id="randomize" onclick="switch_color('random')">Randomize</button>
        <button id="randomize" onclick="switch_color('default')">Default</button>
        <button id="randomize" onclick="switch_color('white')">No colors</button>
    <div id="picker" style="visibility: hidden;margin:2px"></div>
    <!-- </div>
    <div> -->
      <!-- <input type="checkbox" id="edges" onclick="edges()" checked>Show edges -->


      <h2> Drawing options </h2>
      <button id="rotate" onclick="rotate()">Rotate</button>
      <h3> Toggle edges & paths </h3>
      <button id="edgebutton" class="togglebutton" onclick="edges()">Corners</button>
      <button id="pathbutton" class="togglebutton" onclick="paths()">Paths</button>
      <!-- <button id="edgebutton" class="togglebutton" onclick="edges()">Draw Edges</button>
      <button id="pathbutton" class="togglebutton" onclick="paths()">Draw Paths</button> -->
    </div>
    <!--
    </div>
    <div> -->
    <!-- <input type="checkbox" id="paths" onclick="paths()">Show paths -->
    <div class="collapsible">
      <h2> Zoom/pan </h2>
    </div>
    <div class="content">
      <button onclick="zoom_in()">Zoom in</button>
      <button onclick="zoom_out()">Zoom out</button>
      <br>
      <button onclick="move('left')">&#8592;</button>
      <button onclick="move('up')">&#8593;</button>
      <button onclick="move('down')">&#8595;</button>
      <button onclick="move('right')">&#8594;</button>
      <br>
      <button onclick="pan_reset()">Reset view</button>
    </div>
  </div>

  <div class="column middle", id="simulation">
    <div id="sim"></div>
  </div>
  <div class="column right" id="options2">
    <div>
    <h2> Holes </h2>
    <input type="number", id="holeNum", onchange="addHoles()", value="0", min="0" class="numinput"></input>
    <!-- <button id="refresh" onclick="reweight()">Generate w/ Holes</button> -->
    <input type="checkbox" id="autorefresh" checked> Auto generate  </button>
    </div>
    <div id="holes"> </div>

  </div>




</div>

<script> </script>


<script>
tippy('#newhex', {
        content: 'Redraw entire scene',
        placement: 'right',
      });

tippy('#probcolor', {
        content: 'This colors each lozenge by its exact probability of occuring in a tiling',
        placement: 'bottom',
        maxWidth: 200,
        delay: [500, 100],
        theme: 'material'
      });

tippy('#redraw', {
        allowHTML: true,
        content: '<p style="font-size: 9pt;margin:0px;">This redraws the hexagon, with new lozenges and parameters </p>',
        placement: 'bottom',
        maxWidth: 200,
        delay: [1000, 100],
        theme: 'material'
      });

tippy('#edgebutton', {
        content: 'Controls whether a lozenge has a black border or not',
        placement: 'bottom',
        maxWidth: 200,
        delay: [500, 100],
        theme: 'material'
      });

tippy('#pathbutton', {
        content: 'Show paths passing through the lozenges',
        placement: 'bottom',
        maxWidth: 200,
        delay: [500, 100],
        theme: 'material'
      });

</script>


<!-- <div class="row">
  <div>
  <h1>What is a lozenge tiling?</h1>
  </div>

</div> -->
<script type="module">
import { weight_hexagon, gap} from './weight_hexagon.js';
import { Reduction, Matching, Coloring } from './matching.js';
import { Rainbow } from './rainbowvis.js';

let type = "WebGL"
if(!PIXI.utils.isWebGLSupported()){
  type = "canvas"
}
//Create a Pixi Application
// create 1:1 ratio

// Hexagon parameters
var Hexagon = { a:80,
                b:80,
                c:80,
                n:80,
                holes: 0,
                lineThickness: 1,
                verticesShow: false,
                paths: false,
                rotated: 0,
                loz_colors: [0x1cff00, 0xfc0606, 0x0555db],
                //loz_colors: [0xFFFFFF, 0xFFFFFF, 0xFFFFFF],
                draw_edges: false,
                draw_paths: false,
                weight_q: 0.1,
                weight_type: "uniform",
                weight_old: [0, "uniform"],
                parameters_old: [1,1,1,50,0],
                changed: false,
                theme: "default",
                // constants for the grid directions
                u: [1,0],
                v: [-1/2, Math.sqrt(3)/2],
                w: [1/2, Math.sqrt(3)/2]
              }


// Binding size-inputs
document.getElementById("Abox").addEventListener('change', changeHexagon);
document.getElementById("Bbox").addEventListener('change', changeHexagon);
document.getElementById("Cbox").addEventListener('change', changeHexagon);
document.getElementById("Nbox").addEventListener('change', changeHexagon);

function changeHexagon() {
  let n = document.getElementById("Nbox").valueAsNumber;
  Hexagon.n = n;
  Hexagon.a = document.getElementById("Abox").valueAsNumber;
  Hexagon.b = document.getElementById("Bbox").valueAsNumber;
  Hexagon.c = document.getElementById("Cbox").valueAsNumber;

  Hexagon.a = Math.ceil(n*Hexagon.a);
  Hexagon.b = Math.ceil(n*Hexagon.b);
  Hexagon.c = Math.ceil(n*Hexagon.c);

  Hexagon.changed = true;
}

document.getElementById("cweight").addEventListener('change', function() {
  Hexagon.weight_q = this.valueAsNumber;
});

document.getElementById("wtype").addEventListener('change', function() {
  Hexagon.weight_type = this.value;
});


// const windowsize = Math.min(window.innerWidth,window.innerHeight);
// change size when window is resized
// window.addEventListener('resize', changeHexSize);
let widthx = document.getElementById("sim").offsetWidth;
let heightx = document.getElementById("sim").offsetHeight;

let app = new PIXI.Application({
	autoResize: true,
  resizeTo: document.getElementById("sim"),
  // width: 2000,
  // height: 1000,
  antialias: true,
  transparent: true,
  resolution: 2
}
);

// Add the Pixi canvas that to the HTML document
document.getElementById("sim").appendChild(app.view);

// initialize weight, probability and matching matrix
var W;
var P;
var M;
let sprites = {};
// load and run the `setup` function when it's done
const loader = new PIXI.Loader();
loader
// .add('images/loz_sprites.json')
// .add('images/loz_edges.json')
.load(setup);


// Paints the first matching
function setup() {

  // create the hexagon
  createHexagon()

  // get hexagon parameters
  const a = Hexagon.a,
        b = Hexagon.b,
        c = Hexagon.c;

  // create underlying weights
  W = [];
  const winput = choose_weight();
  W = weight_hexagon(winput,a,b,c);

  // add the holes
  // give W a matrix with positions of holes, initialize first
  W.holes = [];
  for (let i=0; i<W.length; i++) {
    W.holes[i] = [];
    W.holes[i].length = W.length;
    W.holes[i].fill(0);
  }

  // compute reduction
  P = Reduction(W);

  // get matching
  M = Matching(P, W[0].length);

  // draw matching
  drawHexagon(M,W.holes);

  // add container for hole controls
  Hexagon.holes = 0;
  let container = new PIXI.Container();
  app.stage.addChildAt(container,1);
  container.x = app.screen.width/2;
  container.y = app.screen.height/2;


}



function createHexagon() {
  // createHexagon draws the Hexagon lozenges
  let width = app.resizeTo.offsetWidth;
  let height  = app.resizeTo.offsetHeight;

  // get hexagon parameters
  const a = Hexagon.a,
        b = Hexagon.b,
        c = Hexagon.c;

  // constants for the grid directions
  const u = Hexagon.u;
  const v = Hexagon.v;
  const w = Hexagon.w;

  // length of unit to fit the screen / normalize into canvas
  const rx = width/(-a * v[0] + b * u[0] + c * w[0]);
  const ry = height/(a * v[1] + c * w[1]);
  const r = 0.9*Math.min(rx/2,ry/2);

  // save r
  Hexagon.r = r;

  // drawing options;
  // draw edges
  let lineThickness = Hexagon.lineThickness;
  if (!Hexagon.draw_edges) {
    lineThickness = 0;
  }
  // draw paths
  const paths = Hexagon.draw_paths;

  // center of hexagon
  const x_center = r*(a * v[0] + b * u[0] + c * w[0]);
  const y_center = r*(a * v[1] + b * u[1] + c * w[1]);

  // create container
  //let container = new PIXI.ParticleContainer((2*(a+c)-1)*(2*(b+c)-1), {tint: true});
  let container = new PIXI.Container();
  app.stage.addChildAt(container,0);

  // put hexagon in the middle
  container.x = width/2;
  container.y = height/2;

  // rotate hexagon if chosen
  container.rotation = Hexagon.rotated;


  // store lozenges
  app.stage.lozenges = [];
  for (let i = 0; i < 2*(a+c)-1; i++) {
    for (let j = 0; j < 2*(b+c)-1; j++) {
      // add lozenge to container and to lozenges for future access
      if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a && j < 2*b + i)) {

        // current coordinate of hexagon center
        const x_cord = r*(j * u[0] + i * v[0]);
        const y_cord = r*(j * u[1] + i * v[1]);

        // transform up-down
        const x0 = -x_center + x_cord;
        const y0 = y_center - y_cord;
        let lozenge;
        let lozvertex;
        if (j % 2 == 0 && i % 2 == 0) {
          // (even,even) position lozenge
          lozenge = createLozenge(x0, y0, r, 1, lineThickness, paths);
          lozenge.type = 1;
        } else if (j % 2 == 1 && i % 2 == 0) {
          // (even,odd) position lozenge
          lozenge = createLozenge(x0, y0, r, 2, lineThickness, paths);
          lozenge.type = 2;
        } else if (j % 2 == 0 && i % 2 == 1) {
          // (odd,even) position lozenge
          lozenge = createLozenge(x0, y0, r, 3, lineThickness, paths);
          lozenge.type = 3;
        } else {
          continue;
        }
        // hide all lozenges until the matching activates the relevant ones
        lozenge.visible = false;
        // give coord to lozenge
        lozenge.i = i;
        lozenge.j = j;
        app.stage.lozenges.push(lozenge);
        container.addChild(lozenge);
      }
    }
  }
  // {let vertex2 = createVertex(x_center,y_center);
  // container.addChild(vertex2);}
  // {let vertex2 = createVertex(-300,-300);
  // container.addChild(vertex2);}
  // {let vertex2 = createVertex(400,400);
  // container.addChild(vertex2);}
  // let vertex2 = createVertex(-r, -Math.sqrt(3) * r);
  // // let vertex3 = createVertex(-x_center+ r*(2*a * v[0]),y_center- r*(2*a * v[1]));
  // let vertex3 = createVertex(3*r, -Math.sqrt(3) * r);
  // container.addChild(vertex3);
  // let vertex4 = createVertex(-x_center+ r*(2*b * u[0]),y_center- r*(2*b * u[1]));
  // container.addChild(vertex4);
}


function changeHexSize() {
  app.stage.removeChildAt(0);
  createHexagon()
  // draw matching
  drawHexagon(M,W.holes);
}



function createLozenge(xPos, yPos, r, type, lineThickness = 1, paths = false)
{
  let loz = new PIXI.Graphics();
  loz.x = xPos;
  loz.y = yPos;
  if (type == 1) { //
    // loz.x = xPos - r/2;
    // loz.y = yPos + r*Math.sqrt(3)/2;
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = Hexagon.loz_colors[0];
    loz.lineStyle(1, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(2*r, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.endFill();

    // if we want paths we set tint to 0 and draw a line in middle
    if (paths == 1) {
      //loz.tint = 0xFFFFFF;
      loz.lineStyle(1, 0x000000);
      loz.moveTo(-r/2,-r*Math.sqrt(3)/2);
      loz.lineTo(3*r/2, -r*Math.sqrt(3)/2);
    }

  } else if (type == 2) { // top lozenge
    loz.x += r;
    // loz.y = yPos + r*Math.sqrt(3)/2;
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = Hexagon.loz_colors[1];
    loz.lineStyle(1, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.lineTo(-2*r, 0);
    loz.lineTo(0,0);
    loz.endFill();

  } else if (type == 3) { //
    loz.x += r/2;
    loz.y += r*Math.sqrt(3)/2;
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = Hexagon.loz_colors[2];
    loz.lineStyle(1, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(0, -2*r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.lineTo(0, 0);
    loz.endFill();

    // if we want paths we set tint to 0 and draw a line in middle
    if (paths) {
      //loz.tint = 0xFFFFFF;
      loz.lineStyle(1, 0x000000);
      loz.moveTo(-r/2, -r*Math.sqrt(3)/2);
      loz.lineTo(r/2, -3*r*Math.sqrt(3)/2);
    }

  }
  return loz
}

function createVertex(xPos, yPos) {
  let vertex = new PIXI.Graphics();
  vertex.x = xPos;
  vertex.y = yPos;
  vertex.beginFill(0x000000);
  vertex.drawCircle(0, 0, 3);
  vertex.endFill();
  return vertex
}



function refresh() {
  M = Matching(P, W[0].length);
  drawHexagon(M,W.holes);
}

function animatehex() {
  // animate/stopped
  let ticker = PIXI.Ticker.shared;
  ticker.maxFPS = 1;
  if (!ticker.started) {
    ticker.add(() => {
        M = Matching(P, W[0].length);
        drawHexagon(M,W.holes);
    });
  }
}

function pause() {
  // toggle start / stop
  PIXI.Ticker.shared.stop();
}

function rotate() {
  let container = app.stage.children[0];
  if (container.rotation == 0) {
    container.rotation = Math.PI/6;
    // if (app.stage.children.length > 1) {
    //   app.stage.children[1].rotation = Math.PI/6;
    // }
    Hexagon.rotated = Math.PI/6;
  } else {
    container.rotation = 0;
    // if (app.stage.children.length > 1) {
    //   app.stage.children[1].rotation = 0;
    // }
    Hexagon.rotated = 0;
  }
}


// function for toggling edges on and off
function edges(choice="toggle") {
  //Hexagon.lineThickness = document.getElementById("edges").checked;
  if (choice == "toggle") {
    if (Hexagon.draw_edges) {
      Hexagon.draw_edges = false;
      document.getElementById("edgebutton")
        .setAttribute("class", "togglebutton");
    } else {
      Hexagon.draw_edges = true;
      document.getElementById("edgebutton")
        .setAttribute("class", "togglebuttonpressed");
    }
  } else if (choice=="edges") {
    Hexagon.draw_edges = true;
    document.getElementById("edgebutton")
      .setAttribute("class", "togglebuttonpressed");
  } else if (choice=="no edge") {
    Hexagon.draw_edges = false;
    document.getElementById("edgebutton")
      .setAttribute("class", "togglebutton");
  }
  regraphics();

}

// function for toggling paths on and off
function paths(choice="toggle") {
  //Hexagon.lineThickness = document.getElementById("edges").checked;
  if (choice == "toggle") {
    if (Hexagon.draw_paths) {
      Hexagon.draw_paths = false;
      document.getElementById("pathbutton")
        .setAttribute("class", "togglebutton");
    } else {
      Hexagon.draw_paths = true;
      document.getElementById("pathbutton")
        .setAttribute("class", "togglebuttonpressed");
    }
  } else if (choice=="edges") {
    Hexagon.draw_paths = true;
    document.getElementById("pathbutton")
      .setAttribute("class", "togglebuttonpressed");
  } else if (choice=="no edge") {
    Hexagon.draw_paths = false;
    document.getElementById("pathbutton")
      .setAttribute("class", "togglebutton");
  }
  regraphics();
}

function reDraw() {
  pan_reset();
  if (Hexagon.changed) {
    app.stage.children = [];
    document.getElementById("holeNum").value = "0";
    Hexagon.holes = 0;

    let div = document.getElementById("holes");
    div.innerHTML = '';

    if (Hexagon.n > 30) {
      Hexagon.draw_edges = false;
      document.getElementById("edgebutton")
        .setAttribute("class", "togglebutton");
      }
    setup();
  } else {
    reweight();
  }
  Hexagon.changed = false;
}

function regraphics() {
  app.stage.removeChildAt(0);
  createHexagon();
  drawHexagon(M, W.holes);
}

function reweight() {
  pause();
  if (!document.getElementById("autorefresh").checked) {
    return;
  }

  const A = Hexagon.a,
        B = Hexagon.b,
        C = Hexagon.c;

  // get the base weight
  W = weight_hexagon(choose_weight(),A,B,C);

  // add the holes
  W.holes = [];
  for (let i=0; i<W.length; i++) {
    W.holes[i] = [];
    W.holes[i].length = W.length;
    W.holes[i].fill(0);
  }

  // add holes to W
  for (let i=0;i<Hexagon.holes;i++) {
    const width = document.getElementById(`holeW${i}`).valueAsNumber;
    const height = document.getElementById(`holeH${i}`).valueAsNumber;
    const X = document.getElementById(`holeX${i}`).valueAsNumber;
    const Y = document.getElementById(`holeY${i}`).valueAsNumber;
    const type = document.getElementById(`holeType${i}`).valueAsNumber;
    W = gap(W,A,B,C,width,X,Y,type,height);
  }

  P = Reduction(W);
  M = Matching(P, W[0].length);
  drawHexagon(M, W.holes);
}


function onDown(e) {
  this.data = e.data;
  this.dragging = true;
}

function onDragMove(e)
{

	if (this.dragging)
    {
      var newPosition = this.data.getLocalPosition(this.parent);
      const r = Hexagon.r;
      //
      // let x = (3*newPosition.x - Math.sqrt(3) * newPosition.y)/(12*r);
      // let y = (-newPosition.x - Math.sqrt(3) * newPosition.y)/(4*r);
      //
      // x = Math.round(x);
      // y = Math.round(y);
      //
      // this.position.x = (3*x-y)*r;
      // this.position.y = -Math.sqrt(3)*(x+y)*r;
      //
      // const num = this.number;
      // document.getElementById(`holeX${num}`).setAttribute("value", 2*x);
      // document.getElementById(`holeY${num}`).setAttribute("value", y);
      if (Hexagon.rotated == 0) {

        let x = (3*newPosition.x - Math.sqrt(3) * newPosition.y)/(12*r);
        let y = (-newPosition.x - Math.sqrt(3) * newPosition.y)/(4*r);

        x = Math.round(x);
        y = Math.round(y);

        this.position.x = (3*x-y)*r;
        this.position.y = -Math.sqrt(3)*(x+y)*r;

        const num = this.number;
        document.getElementById(`holeX${num}`).setAttribute("value", 2*x);
        document.getElementById(`holeY${num}`).setAttribute("value", y);

        // let x = (newPosition.x)/(2*r);
        // let y = (newPosition.y)/(Math.sqrt(3)*r);
        //
        // x = Math.round(x);
        // y = Math.round(y);
        //
        // //(2*x-y)*r;
        // if (y % 2 == 0) {
        //   this.position.x = 2*r*x;
        //     this.position.y = Math.sqrt(3)*r*y;//-Math.sqrt(3)*y*r;
        // } else {
        //     this.position.y = Math.sqrt(3)*r*y
        //     this.position.x = r*(2*x-1);
        // }
        //
        // const num = this.number;
        // document.getElementById(`holeX${num}`).setAttribute("value", x+y);
        // document.getElementById(`holeY${num}`).setAttribute("value", -y);

      } else {
        const xscale = 2*r*Math.sqrt(3);
        const yscale = 2*r;
        const x = Math.round(newPosition.x/(xscale));
        const y = Math.round((newPosition.y)/(yscale));

        this.position.x = x*xscale;
        this.position.y = y*yscale;

        const num = this.number;
        document.getElementById(`holeX${num}`).setAttribute("value", 2*x);
        document.getElementById(`holeY${num}`).setAttribute("value", -y);
      }
    }

}

function onDragEnd()
{
    this.dragging = false;
    // get number of circle and get width
    const num = this.number;
    const width = document.getElementById(`holeW${num}`).valueAsNumber

    if (width > 0) {
      reDraw()
    }
    // set the interaction data to null
    this.data = null;
}

function hole(container, num) {
  // choose random color
  var rainbow = new Rainbow();
  rainbow.setSpectrum('#ffffff','#000000');
  let color = rainbow.colorAt(10*num);

  // all the vertices
  let vertex = new PIXI.Graphics();
  vertex.interactive = true;
  vertex.buttonMode = true;
  vertex.beginFill('0x'+ color);
  vertex.on('mousedown', onDown)
        .on('touchstart', onDown)
      .on('mousemove', onDragMove)
      .on('touchmove', onDragMove)
      .on('mouseup', onDragEnd)
      .on('mouseupoutside', onDragEnd)
      .on('touchend', onDragEnd)
      .on('touchendoutside', onDragEnd);
      // .on('mouseup', onRelease)
      // .on('mouseupoutside',onRelease);
  vertex.lineStyle(2,0x000000);
  vertex.drawCircle(0, 0, 8);
  vertex.endFill();


  vertex.number = num;
  container.addChildAt(vertex,0);
  // vertex.x = -Hexagon.r/2;
  // vertex.y = Hexagon.r*Math.sqrt(3)/2;

  const A = Hexagon.a,
        B = Hexagon.b,
        C = Hexagon.c;
  const max = Math.min(A+B,A+C)/2;

  // make title
  let div = document.getElementById("holes");
  //div.innerHTML += `<h2> Hole ${num+1} </h2>`

  let buttongroup = document.createElement("DIV");

  //document.body.appendChild(title)
  buttongroup.setAttribute("class","hole");
  buttongroup.setAttribute("style","background-color: #" + color);
  buttongroup.setAttribute("id", `holegroup${num}`);
  buttongroup.innerHTML += `<h3>Hole ${num+1}: Width</h3>`;
  let Iwidth = document.createElement("INPUT");
  Iwidth.setAttribute("type", "range");
  Iwidth.setAttribute("value", 0);
  Iwidth.setAttribute("id", `holeW${num}`);
  Iwidth.setAttribute("step", "1");
  Iwidth.setAttribute("min", "0");
  Iwidth.setAttribute("max", `${max}`);
  Iwidth.setAttribute("onchange", "reDraw()")
  buttongroup.appendChild(Iwidth);


  buttongroup.innerHTML += `<h3>Height</h3>`;
  let Iheight = document.createElement("INPUT");
  Iheight.setAttribute("type", "range");
  Iheight.setAttribute("value", 1);
  Iheight.setAttribute("id", `holeH${num}`);
  Iheight.setAttribute("step", "1");
  Iheight.setAttribute("min", "1");
  Iheight.setAttribute("max", `${max}`);
  Iheight.setAttribute("onchange", "reDraw()")
  buttongroup.appendChild(Iheight);


  buttongroup.innerHTML += `<h3>(X,Y) position and type</h3>`;
  let Ix = document.createElement("INPUT");
  Ix.setAttribute("type", "number");
  Ix.setAttribute("value", 0);
  Ix.setAttribute("id", `holeX${num}`);
  Ix.setAttribute("class", 'holeinput');
  Ix.setAttribute("step", "2");
  Ix.setAttribute("onchange", "reDraw()")
  // Ix.setAttribute("class", "numinput");
  buttongroup.appendChild(Ix);


  //buttongroup.innerHTML += `<h3>Y-pos<h3>`;
  let Iy = document.createElement("INPUT");
  Iy.setAttribute("type", "number");
  Iy.setAttribute("value", 0);
  Iy.setAttribute("id", `holeY${num}`);
  Iy.setAttribute("class", 'holeinput');
  Iy.setAttribute("onchange", "reDraw()");
  // Iy.setAttribute("class", "numinput");
  buttongroup.appendChild(Iy);

  //buttongroup.innerHTML += `<h3>Type<h3> `;
  let Itype = document.createElement("INPUT");
  Itype.setAttribute("type", "number");
  Itype.setAttribute("value", 1);
  Itype.setAttribute("min", 1);
  Itype.setAttribute("max", 6);
  Itype.setAttribute("step", 1);
  Itype.setAttribute("class", 'holeinput');
  Itype.setAttribute("id", `holeType${num}`);
  Itype.setAttribute("onchange", "reDraw()");
  // Itype.setAttribute("class", "numinput");
  buttongroup.appendChild(Itype);

  div.appendChild(buttongroup);


}

function addHoles() {
  // change in number of holes
  const current_holes = document.getElementById("holeNum").valueAsNumber
  const holechange = current_holes - Hexagon.holes;
  let div = document.getElementById("holes");
  let container = app.stage.children[1];

  if (holechange > 0) { // add prescribed holes
    for (let i=0; i<holechange; i++) {
      hole(container, Hexagon.holes+i);
    }
  } else if (holechange < 0) { // remove holes
    for (let i=Hexagon.holes; i>current_holes; i--) {
      // remove buttongroup for hole
      document.getElementById(`holegroup${i-1}`).remove();
    }
    // remove hole controller, last element is first in container
    container.removeChildren(0,-holechange);
  } else {
  }
  Hexagon.holes = document.getElementById("holeNum").valueAsNumber;
}


function qweight(N, a) {
  let bottom;
  let top;
  if (a == 0) {
    bottom = [1];
    top = [1];
  } else {
    const q = Math.exp(-a/N);
    top = new Array(N);
    top.fill(1);
    bottom = new Array(N);
    for (let k=0;k<N;k++) {
      bottom[k] = q**k;
    }
  }
  return [bottom, top];
}

function choose_weight() {
  let weight;
  const A = Hexagon.a,
        B = Hexagon.b,
        C = Hexagon.c;
  const type = Hexagon.weight_type;
  const N = B+C+1;
  const a = Hexagon.weight_q;
  // const A = document.getElementById("Abox").valueAsNumber;
  // const B = document.getElementById("Bbox").valueAsNumber;
  // const C = document.getElementById("Cbox").valueAsNumber;
  const kappa = document.getElementById("kappa").valueAsNumber;
  const nums = document.getElementById("rownums").valueAsNumber;
  if (type == "uniform") {
    weight = [[1],[1]];
  } else if (type == "qvolume") {
    const q = Math.exp(-a/N);
    // make array
    let bottom = new Array(N);
    bottom.fill(1);
    let top = new Array(N);
    for (let k=0;k<N;k++) {
      top[k] = q**k;
    }
    weight = [top, bottom];
  } else if (type == "periodic1x2") {
    weight = [[1, 1], [a, 1]];
  } else if (type == "periodic2x2") {
    weight = [[a, 1], [1, 1], [1, a], [1, a**2]];
  } else if (type == "periodic2x3") {
    weight = [[a,1,1], [a,1,1], [1,1,a], [1,1,a]];
  } else if (type == "qracah") {
    const q = Math.exp(-a/N);
    // make array
    let bottom = new Array(N);
    bottom.fill(1);
    let top = new Array(N);
    for (let k=0;k<N;k++) {
      top[k] = kappa*q**k - 1/(kappa*q**k);
    }
    weight = [top, bottom];
  } else if (type == "racah") {
      let bottom = new Array(N);
      bottom.fill(1);
      let top = new Array(N);
      for (let k=0;k<N;k++) {
        top[k] = a + k;
      }
      weight = [top, bottom];
  } else if (type == "trigqracah") {
      const q = Math.exp(-a/N);
      // make array
      let bottom = new Array(N);
      bottom.fill(1);
      let top = new Array(N);
      for (let k=0;k<N;k++) {
        top[k] = kappa*q**k - 1/(kappa*q**k);
      }
      weight = [top, bottom];
  } else if (type == "custom") {
    // let rows = document.getElementById("rownums").valueAsNumber
    // let c = Math.ceil(Math.random(2)+0.5);
    // let d = Math.random(1);
    // weight = [[a,a**c,d**(c+1)], [a,a**c,c**(c+1)]];
    weight = []
    // //bottom.fill(1);
    let xmod = Math.round(nums);
    let ymod = Math.round(kappa);
    //console.log([xmod, ymod])
    for (let i=0;i<N;i++) {
      let row = [];
      for (let k=0;k<N;k++) {
        if (i % ymod == 0 && k % xmod == 0) {
          row.push(1);
        } else if (i % ymod == 0 && k % xmod > 0) {
          row.push(a**(k % xmod));
        } else if (i % ymod > 0 && k % xmod == 0) {
          row.push(a**(i % ymod));
        } else {
          row.push(0.5*(a**(i % ymod)+a**(k % xmod)));
        }
      }
      weight.push(row);
    }
  } else if (type == "weird1") {
    weight = []
    // //bottom.fill(1);
    let xmod = 3;
    let ymod = 3;
    //console.log([xmod, ymod])
    for (let i=0;i<N;i++) {
      let row = [];
      for (let k=0;k<N;k++) {
        if (i % ymod == 0 && k % xmod == 0) {
          row.push(1);
        } else if (i % ymod == 0 && k % xmod > 0) {
          row.push(1);
        } else if (i % ymod > 0 && k % xmod == 0) {
          row.push(a**(i % xmod - k % ymod));
        } else {
          row.push(1);
        }
      }
      weight.push(row);
    }
  }
  return weight
}


function Array2D(n) {
  let M = [];
  for (let i=0; i<n; i++) {
    const row = new Array(n)
    row.fill(0)
    M.push(row);
  }
  return M;
}



function addVertices() {
  let vertexcontainer = new PIXI.Container();
  for (let i=0;i<app.stage.vertices.length;i++) {
    vertexcontainer.addChild(app.stage.vertices[i]);
  }
  vertexcontainer.position = app.stage.children[0].position;
  //vertexcontainer.rotation = Hexagon.rotated;
  app.stage.addChild(vertexcontainer);
}

function hidewform() {
  const wtype = document.getElementById("wtype").value;
  if (wtype == "uniform") {
    document.getElementById("cweight").style.display = "none";
  } else {
    document.getElementById("cweight").style.display = "inline";
  }
  if (wtype == "custom") {
    document.getElementById("rownums").style.display = "inline";
    document.getElementById("rows").style.display = "inline";
    document.getElementById("kappa").style.display = "inline";
  } else {
    document.getElementById("rownums").style.display = "none";
    document.getElementById("rows").style.display = "none";
    document.getElementById("kappa").style.display = "none";
  }
 }

function qracahupdate() {
  const newkappa = document.getElementById("kappa").valueAsNumber;
  document.getElementById("kappanum").setAttribute("value", newkappa);
}

var colorpick_active = [];
function colorpick(elem) {
  let boxnum = elem.id.slice(-1)[0]
  if (!colorpick_active.includes(boxnum)) {
    colorpick_active.push(boxnum);
    document.getElementById("picker").style.visibility = "visible";

    let current_color = elem.style.fill;
    //var colbox = document.getElementById("colorbox1");
    var colorPicker = new iro.ColorPicker("#picker", {
      // Set the size of the color picker
      width: 150,
      id: 'colorwheel'+boxnum,
      // Set the initial color to pure red
      color: current_color,
      padding: 0,
      margin: 5
    });
    colorPicker.on(["color:init", "color:change"], function(color){
    // Show the current color in different formats
    elem.style.fill = color.hexString;
    let newcolor = '0x' + color.hexString.substr(1,6);
    // get last number from id
    switch (boxnum) {
      case "1":
        Hexagon.loz_colors[0] = newcolor;
        break;
      case "2":
        Hexagon.loz_colors[1] = newcolor;
        break;
      case "3":
        Hexagon.loz_colors[2] = newcolor;
    }
    renew_color();
    });
  } else {
  //colorpick_active = 0;
  // if color wheel already exists, clicking again removes it
  colorpick_active = colorpick_active.filter(item => item !== boxnum);
  document.getElementById("colorwheel"+boxnum).remove();
  // if all color wheels are removed, hide parent div
  if (colorpick_active.length == 0) {
    document.getElementById("picker").style.visibility = "hidden";
    document.getElementById("picker").innerHTML = "";
  }
}
}


function randomHex(prefix='') {
  const nums = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];
  let hex = prefix;
  for (let i=0;i<6;i++) {
    let rndHex = nums[Math.floor(Math.random() * Math.floor(16))];
    hex += rndHex;
  }
  return hex;
}

// updates the lozenges using matching matrix M
function drawHexagon(M,holes,M_acc = []) {
  let lozenges = app.stage.lozenges;
  for (let k=0, len=lozenges.length; k<len; k++) {
    const i = lozenges[k].i;
    const j = lozenges[k].j;
    if (M[i][j] && !holes[holes.length-1-i][j])  {
      lozenges[k].visible = true;
    } else {
      lozenges[k].visible = false;
    }
  }
  if (Hexagon.theme == "probability") {
    prob_color();
  }
}



function renew_color() {
  Hexagon.theme = "default";
  let lozenges = app.stage.lozenges;
  for (let k=0, len=lozenges.length; k<len; k++) {
    const type = lozenges[k].type;
    switch (type) {
      case 1:
        lozenges[k].tint = Hexagon.loz_colors[0];
        break;
      case 2:
        lozenges[k].tint = Hexagon.loz_colors[1];
        break;
      case 3:
        lozenges[k].tint = Hexagon.loz_colors[2];
    }
  }
}


function switch_color(opt) {
  Hexagon.theme = "default";
  switch (opt) {
    case "default":
      Hexagon.loz_colors[0] = 0x1cff00;
      Hexagon.loz_colors[1] = 0xfc0606;
      Hexagon.loz_colors[2] = 0x0555db;

      document.getElementById("colorbox1").style.fill = "#1cff00";
      document.getElementById("colorbox2").style.fill  = "#fc0606";
      document.getElementById("colorbox3").style.fill  = "#0555db";
      renew_color()
      break;
    case "random":
      // pick random colors
      const color1 = randomHex();
      const color2 = randomHex();
      const color3 = randomHex();

      Hexagon.loz_colors[0] = '0x' + color1;
      Hexagon.loz_colors[1] = '0x' + color2;
      Hexagon.loz_colors[2] = '0x' + color3;

      document.getElementById("colorbox1").style.fill = "#"+color1;
      document.getElementById("colorbox2").style.fill  = "#"+color2;
      document.getElementById("colorbox3").style.fill  = "#"+color3;
      renew_color()
      break;
    case "white":
      Hexagon.loz_colors[0] = 0xFFFFFF;
      Hexagon.loz_colors[1] = 0xFFFFFF;
      Hexagon.loz_colors[2] = 0xFFFFFF;

      document.getElementById("colorbox1").style.fill = "#FFFFFF";
      document.getElementById("colorbox2").style.fill  = "#FFFFFF";
      document.getElementById("colorbox3").style.fill  = "#FFFFFF";
      renew_color()
      break;
  }
}

function prob_color() {
  Hexagon.theme = "probability";
  let C = Coloring(P,W[0].length);

  let lozenges = app.stage.lozenges;
  var rainbow = new Rainbow();

  for (let k=0, len=lozenges.length; k<len; k++) {
    const i = lozenges[k].i;
    const j = lozenges[k].j;
    // color takes value from 1,100
    const color = Math.floor(100*C[i][j]);
    lozenges[k].tint = '0x'+ rainbow.colorAt(color);
  }

}


var step = -10;
function zoom_in() {
  if (app.stage.children[1]) {
    app.stage.children[1].visible = false;
  }
  app.stage.children[0].scale.x *= 2;
  app.stage.children[0].scale.y *= 2;
  step *= 2;
}

function zoom_out() {
  if (app.stage.children[0].scale.x > 1 && app.stage.children[0].scale.y > 1) {
    app.stage.children[0].scale.x *= 0.5;
    app.stage.children[0].scale.y *= 0.5;
    app.stage.children[0].position.x = widthx/2;
    app.stage.children[0].position.y = heightx/2;
    step *= 0.5;
  } else {
    if (app.stage.children[1]) {
      app.stage.children[1].visible = true;
    }
  }
}

function move(dir) {
  //let step = -10;
  switch (dir) {
    case "left":
      app.stage.children[0].position.x += -step;
      if (app.stage.children[1]) {
        app.stage.children[1].position.x += -step;
      }
      break;
    case "right":
      app.stage.children[0].position.x += step;
      if (app.stage.children[1]) {
        app.stage.children[1].position.x += step;
      }
      break;
    case "up":
      app.stage.children[0].position.y += -step;
      if (app.stage.children[1]) {
        app.stage.children[1].position.y += -step;
      }
      break;
    case "down":
      app.stage.children[0].position.y += step;
      if (app.stage.children[1]) {
        app.stage.children[1].position.y += step;
      }
  }
}

function pan_reset() {
  app.stage.children[0].scale.x = 1;
  app.stage.children[0].scale.y = 1;
  app.stage.children[0].position.x = widthx/2;
  app.stage.children[0].position.y = heightx/2;
  step = -10;
  if (app.stage.children[1]) {
    app.stage.children[1].visible = true;
    app.stage.children[1].position.x = widthx/2;
    app.stage.children[1].position.y = heightx/2;
  }
}


var panning = false;
function pan() {
  let hexcontainer = app.stage.children[0];
  if (!hexcontainer.interactive) {
    hexcontainer.interactive = true;
    hexcontainer.buttonMode = true;
  } else {
    hexcontainer.interactive = false;
    hexcontainer.buttonMode = false;
  }
  hexcontainer.on('mousedown', onDownPan)
      .on('mousemove', onDragMovePan)
      .on('mouseup', onDragEndPan)
      .on('mouseupoutside', onDragEndPan)
}

// hexcontainer.on('mousedown', zoom_in);

function onDownPan(e) {
  this.data = e.data;
  this.dragging = true;
}
function onDragMovePan(e) {
  let hexcontainer = app.stage.children[0];
	if (this.dragging) {
    var newPosition = this.data.getLocalPosition(this.parent);
    this.position.x = newPosition.x;
    this.position.y = newPosition.y;
  }

}
function onDragEndPan()
{
    this.dragging = false;
    this.data = null;
}


function addrow() {

}

// Collapsible menus
{
let coll = document.getElementsByClassName("collapsible");
for (let i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
}

window.reweight = reweight;
window.reDraw = reDraw;
window.edges = edges;
window.refresh = refresh;
window.rotate = rotate;
window.animatehex = animatehex;
window.prob_color = prob_color;
window.pause = pause;
window.gap = gap;
window.paths = paths;
window.addHoles = addHoles;
window.weight_hexagon = weight_hexagon;
window.qweight = qweight;
window.hidewform = hidewform;
window.qracahupdate = qracahupdate;
window.Rainbow = Rainbow;
window.colorpick = colorpick;
window.switch_color = switch_color;
window.randomHex = randomHex;
window.zoom_in = zoom_in;
window.zoom_out = zoom_out;
window.pan = pan;
window.move = move;
window.pan_reset = pan_reset;
//window.gap100 = gap100;
window.changeHexagon = changeHexagon;
window.Hexagon = Hexagon;
window.regraphics = regraphics;
window.addrow = addrow;

</script>

</body>
</html>
