<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lozenge tiling</title>

  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>

</head>
<body>

<div class="row">
  <div class="column", id="simulation">
  	<div id="sim"></div>
  </div>
  <div class="options" id="options1">
    <h2> Hexagon Parameters </h2>
    <h3> General hexagon, sides A,B,C</h3>
    <div class="grid-container">
      <div class="grid-item">
        <div id="inputA" class="input0">
        <h3> A: </h3>
        <input type="number" value="50" id="Abox" name="A" class="numinput">
        </div>
      </div>
      <div class="grid-item">
        <div id="inputB" class="input0">
          <h3> B: </h3>
          <input type="number" value="50" id="Bbox" name="B" class="numinput">
        </div>
      </div>
      <div class="grid-item">
        <div id="inputC" class="input0">
          <h3> C: </h3>
          <input type="number" value="50" id="Cbox" name="C" class="numinput">
        </div>
      </div>
    </div>

    <h3> Weight </h3>
  	<div id="inputW" class="input0">
      <select id="wtype" onchange="hidewform()">
      <option value="uniform" selected="selected">Uniform</option>
      <option value="qvolume">q-Volume</option>
      <option value="periodic1x2">1x2 Periodic</option>
      <option value="periodic2x2">2x2 Periodic</option>
      <option value="periodic2x3">2x3 Periodic</option>
      <option value="qracah">real q-Racah</option>
      <option value="racah">Racah</option>
      </select>
      <input type="number" value="0" step="0.1" id="cweight" name="Wweight"
             class="numinput" style="display:none"/>
      <div>
      <input type="range" id="kappa" min="0.0001" max="4" step="0.01" name="kappaw" style="display:none;width:100px" onchange="qracahupdate()" />
      <input type="number" id="kappanum" style="display:none;width:40px" />
      </div>


    </div>


    <h3> Regular hexagon, sidelengths N</h3>
  	<div id="inputN", class="input0">
      <input type="number" value="50" id="Nbox" name="N" class="numinput" onchange="regularHex()">
    </div>


    <h2> Generate Tilings</h2>
    <div>
    <button id="newhex", onclick="myFunction()">Generate new hexagon</button>
    </div>
    <h3> Reweight (same hexagon dims)</h3>
    <div>
    <button id="refresh" onclick="reweight()">Reweight</button>
    </div>

    <h3> Rematch (same weight) </h3>
	  <div>
    <button id="refresh" onclick="refresh()">Rematch</button>
    </div>
    <h3> Generate a large number of <br> tilings and display average </h3>
	  <div>
	    <button id="animatehex" onclick="animatehex()">Animate</button>
        <button id="pause" onclick="pause()">Stop</button>
    </div>
    <h3> This colors each lozenge by <br> its exact probability of occuring</h3>
    <div>
      <button id="probcolor" onclick="prob_color()">Probability color</button>
    </div>
	<h2> Properties </h2>
    <!-- <div>
    <button id="rotate" onclick="rotate()">Rotate</button>
    </div> -->
    <div>
      <button id="randomize" onclick="randomize_color()">Randomize colors</button>
    </div>
    <div>
      <button id="randomize" onclick="default_color()">Default colors</button>
    </div>

    <div>
      <input type="checkbox" id="edges" onclick="edges()" checked>Show edges</button>
    </div>
    <div>
    <input type="checkbox" id="paths" onclick="paths()">Show paths</button>
    </div>
  </div>


  <div class="options" id="options2">
    <h2> Holes </h2>
    <div>
    <input type="number", id="holeNum", onchange="addHoles()", value="0", min="0" class="numinput"></input>
    <button id="refresh" onclick="reweight()">Generate w/ Holes</button>
    </div>

    <div>
    <input type="checkbox" id="autorefresh" checked>Auto generate</button>
    </div>
    <div id="holes"> </div>
  </div>
</div>

<script type="module">
import { weight_hexagon, gap } from './weight_hexagon.js';
import { Reduction, Matching, Coloring } from './matching.js';

let type = "WebGL"
if(!PIXI.utils.isWebGLSupported()){
  type = "canvas"
}
//Create a Pixi Application
// create 1:1 ratio
const windowsize = Math.min(window.innerWidth,window.innerHeight);

let app = new PIXI.Application({
	autoResize: true,
  width: windowsize,
  height: windowsize,
  antialias: true,
  transparent: true,
  resolution: 2
}
);
// idea: Perhaps create Hexagon object that has all the current properties
// of the hexagon for clarity
// hexagon dimension: A,B,C
// hexagon number of holes:
//

var Hexagon = { a:30,
                b:30,
                c:30,
                holes: 0,
                lineThickness: 1,
                verticesShow: false,
                paths: false,
                rotated: Math.PI/6,
                // constants for the grid directions
                u: [1,0],
                v: [-1/2, Math.sqrt(3)/2],
                w: [1/2, Math.sqrt(3)/2]
              }


//Add the canvas that Pixi automatically created for you to the HTML document
document.getElementById("sim").appendChild(app.view);
// initial probability
var W;
var P;
//load an image and run the `setup` function when it's done
const loader = new PIXI.Loader();
loader
.load(setup());
// This `setup` function will run when the image has loaded
// Paints the matching
function setup() {
  // get hexagon parameters
  const a = document.getElementById("Abox").valueAsNumber;
  const b = document.getElementById("Bbox").valueAsNumber;
  const c = document.getElementById("Cbox").valueAsNumber;

  // draw paths?
  const paths = Hexagon.paths;
  const lineThickness = Hexagon.lineThickness;

  // constants for hexagon dimensions
  const n = a + c;
  const m = b + c;

  // constants for the grid directions
  const u = Hexagon.u;
  const v = Hexagon.v;
  const w = Hexagon.w;

  // length of unit to fit the screen / normalize
  const rx = app.screen.width/(2.1*(b+c));
  const ry = app.screen.height/(2*a+c);
  const r = Math.min(rx,ry);

  // save r
  Hexagon.r = r;

  // app window size and padding
  const height = app.screen.height;
  const width = app.screen.width;

  // center of hexagon
  const x_center = r*(a * v[0] + b * u[0] + c * w[0]);
  const y_center = r*(a * v[1] + b * u[1] + c * w[1]);


  // create container
  let container = new PIXI.Container();
  app.stage.addChildAt(container,0);

  // put hexagon in the middle
  container.x = width/2;
  container.y = height/2;

  // rotate hexagon if chosen
  container.rotation = Hexagon.rotated;

  // store lozenges
  app.stage.lozenges = [];


  // TODo don't draw vertices if not needed.

  for (let i = 0; i < 2*n-1; i++) {
    for (let j = 0; j < 2*m-1; j++) {
      // current coordinate of hexagon center
      const x_cord = r*(j * u[0] + i * v[0]);
      const y_cord = height - r*(j * u[1] + i * v[1]);

      // transform up-down
      const x0 = -x_center + x_cord;
      const y0 = -height + y_center + y_cord;

      // add lozenge to container and to lozenges for future access
      if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a && j < 2*b + i)) {
        let lozenge;
        let lozvertex;
        if (j % 2 == 0 && i % 2 == 0) {
          // (even,even) position lozenge
          lozenge = createLozenge(x0, y0, r, 1, lineThickness, paths);
          lozenge.type = 1;
        } else if (j % 2 == 1 && i % 2 == 0) {
          // (even,odd) position lozenge
          lozenge = createLozenge(x0, y0, r, 2, lineThickness, paths);
          lozenge.type = 2;
        } else if (j % 2 == 0 && i % 2 == 1) {
          // (odd,even) position lozenge
          lozenge = createLozenge(x0, y0, r, 3, lineThickness, paths);
          lozenge.type = 3;
        } else {
          continue;
        }

        // hide all lozenges until the matching activates the relevant ones
        lozenge.visible = false;
        // give coord to lozenge
        lozenge.i = i;
        lozenge.j = j;
        app.stage.lozenges.push(lozenge);
        container.addChild(lozenge);

      }
    }
  }

  // create underlying weights
  W = [];
  //console.log(W);
  const wtype = document.getElementById("wtype").value;
  const cweight = document.getElementById("cweight").valueAsNumber;
  const winput = choose_weight(wtype, cweight, (a+c+1));
  W = weight_hexagon(winput,1,a,b,c);
  //console.log(W);
  // add the holes

  // give W a matrix with positions of holes, initialize first


  W.holes = [];
  for (let i=0; i<W.length; i++) {
    W.holes[i] = [];
    W.holes[i].length = W.length;
    W.holes[i].fill(0);
  }

  // add holes to W
  for (let i=0;i<Hexagon.holes;i++) {
    const width = document.getElementById(`holeW${i}`).valueAsNumber;
    const X = document.getElementById(`holeX${i}`).valueAsNumber;
    const Y = document.getElementById(`holeY${i}`).valueAsNumber;
    const type = document.getElementById(`holeType${i}`).valueAsNumber;
    W = gap(W,a,b,c,width,X,Y, type);
  }
  // compute reduction
  // W = W_split(W);
  P = Reduction(W);

  // get matching

  //MatchingTest(P, W[0].length);
  let M = Matching(P, W[0].length);

  // draw matching
  drawHexagon(M,W.holes);
  //drawHexagon(a,b,c,M,W.holes);
  //
  // {
  // let renderer = PIXI.autoDetectRenderer();
  // let renderTexture = PIXI.RenderTexture.create({ width: 800, height: 600 });
  // let graphics = createLozenge(200,200, 10*r, 1);
  // texture.render(graphics);
  // let s = new PIXI.Sprite(texture);
  //
  // }

}

function createLozenge(xPos, yPos, r, type, lineThickness = 1, paths = 0)
{
  var loz = new PIXI.Graphics();
  if (type == 1) { //
    loz.x = xPos - r/2;
    loz.y = yPos + r*Math.sqrt(3)/2;
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = 0x1cff00;
    loz.lineStyle(1/2, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(2*r, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.endFill();

    // if we want paths we set tint to 0 and draw a line in middle
    if (paths == 1) {
      loz.tint = 0xFFFFFF;
      loz.lineStyle(2, 0x000000);
      loz.moveTo(-r/2,-r*Math.sqrt(3)/2);
      loz.lineTo(3*r/2, -r*Math.sqrt(3)/2);
    }

  } else if (type == 2) { // top lozenge
    loz.x = xPos + r/2;
    loz.y = yPos + r*Math.sqrt(3)/2;
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = 0xfc0606;
    loz.lineStyle(1/2, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.lineTo(-2*r, 0);
    loz.lineTo(0,0);
    loz.endFill();

    // if we want paths we set tint to 0 and draw a line in middle
    if (paths == 1) {
      loz.tint = 0xFFFFFF;
    }

  } else if (type == 3) { //
    loz.x = xPos;
    loz.y = yPos + r*Math.sqrt(3);
    loz.beginFill(0xFFFFFF, 1);
    loz.tint = 0x0555db;
    loz.lineStyle(1/2, 0x000000, lineThickness);
    loz.moveTo(0, 0);
    loz.lineTo(r, -r*Math.sqrt(3));
    loz.lineTo(0, -2*r*Math.sqrt(3));
    loz.lineTo(-r, -r*Math.sqrt(3));
    loz.lineTo(0, 0);
    loz.endFill();

    // if we want paths we set tint to 0 and draw a line in middle
    if (paths == 1) {
      loz.tint = 0xFFFFFF;
      loz.lineStyle(2, 0x000000);
      loz.moveTo(-r/2, -r*Math.sqrt(3)/2);
      loz.lineTo(r/2, -3*r*Math.sqrt(3)/2);
    }

  }
  return loz
}

function createVertex(xPos, yPos) // for drawing vertices
{
  let vertex = new PIXI.Graphics();
  vertex.x = xPos;
  vertex.y = yPos;
  vertex.beginFill(0x000000);
  vertex.drawCircle(0, 0, 1);
  vertex.endFill();
  return vertex
}


// updates the lozenges using matching matrix M
function drawHexagon(M,holes,M_acc = []) {

  let lozenges = app.stage.lozenges;

  for (let k=0, len=lozenges.length; k<len; k++) {
    const i = lozenges[k].i;
    const j = lozenges[k].j;
    if (M[i][j] && !holes[holes.length-1-i][j])  {
      lozenges[k].visible = true;
    } else {
      lozenges[k].visible = false;
    }
  }



}



// function drawHexagon(a,b,c,M,holes,Macc=[]) {
//
//   const n = a+c;
//   const m = b+c;
//
//   for (let i = 0; i < 2*n-1; i++) {
//     for (let j = 0; j < 2*m-1; j++) {
//       // use Matching matrix M to make lozenges visible
//       // use holes matrix to hide lozenges that make up holes
//       if ((i < 2*a && j < 2*b + i) || (i >= 2*a && j > i-2*a && j < 2*b + i)) {
//         if (M[i][j] && !holes[holes.length-1-i][j])  {
//         //if (M[i][j])  {
//           app.stage.lozenges[i][j].visible = true;
//
//           // for animate
//           if (Macc.length > 0) {
//             if (Macc[i][j]/Macc.totno > 0.999) {
//               app.stage.lozenges[i][j].tint = 0x91959a;
//             } else if (Macc[i][j]/Macc.totno > 0.9) {
//               app.stage.lozenges[i][j].tint = 0x000000;
//               //app.stage.lozenges[i][j].tint = (1-0.01*Macc[i][j]/Macc.totno)*0x91959a;
//             } else if (Macc[i][j]/Macc.totno > 0.66) {
//               app.stage.lozenges[i][j].tint = 0x778ff7;
//               //app.stage.lozenges[i][j].tint = (1-0.01*Macc[i][j]/Macc.totno)*0x91959a;
//             } else if (Macc[i][j]/Macc.totno > 0.33) {
//               app.stage.lozenges[i][j].tint = 0xFFFFFF;
//             //   //app.stage.lozenges[i][j].tint = (1-0.01*Macc[i][j]/Macc.totno)*0x91959a;
//             } else if (Macc[i][j]/Macc.totno > 0.05) {
//               app.stage.lozenges[i][j].tint = 0xFFFFFF;
//               //app.stage.lozenges[i][j].tint = (1-0.01*Macc[i][j]/Macc.totno)*0x91959a;
//             } else {
//               app.stage.lozenges[i][j].tint = 0xFFFFFF;
//             }
//             //app.stage.lozenges[i][j].tint = (1-Math.floor((Macc[i][j]/Macc.totno)*4)/4)*0xFFFFFF;
//           }
//         } else {
//           app.stage.lozenges[i][j].visible = false;
//         }
//       }
//     }
//   }
//
// }


function refresh() {
  // just create a new matching (same Weight/Reduction matrix)
  // const A = document.getElementById("Abox").valueAsNumber;
  // const B = document.getElementById("Bbox").valueAsNumber;
  // const C = document.getElementById("Cbox").valueAsNumber;
  let M = Matching(P, W[0].length);
  drawHexagon(M,W.holes);
}

function animatehex() {
  // animate/stopped
  let ticker = PIXI.Ticker.shared;
  //ticker.autoStart = false;
  // initialize accumulating matrix
  // let M_acc = Array2D(W[0].length);
  // M_acc.totno = 0;
  ticker.maxFPS = 30;
  if (!ticker.started) {
    ticker.add(() => {
        //
        let M = Matching(P, W[0].length);

        // //
        // M_acc.totno += 1;
        // addtoArray(M_acc, M);

        // drawHexagon
        drawHexagon(M,W.holes);
    });
  }
}

function prob_color() {
  let C = Coloring(P,W[0].length);

  let lozenges = app.stage.lozenges;

  for (let k=0, len=lozenges.length; k<len; k++) {
    const i = lozenges[k].i;
    const j = lozenges[k].j;
    const c = C[i][j];
    // let colval = Math.round(256*c);
    // let colhex = colval.toString(16);
    //if (c > 0.9) {lozenges[k].tint = 0x000000};
    if (c > 0.99) {
      lozenges[k].tint = 0x91959a;
    } else if (c > 0.8) {
      lozenges[k].tint = 0x000000;
    } else if (c > 0.5) {
      lozenges[k].tint = 0x778ff7;
    } else if (c > 0.35) {
      lozenges[k].tint = 0x73d9ff;
    } else if (c > 0.15) {
      lozenges[k].tint = 0x4fffff;
    } else {
      lozenges[k].tint = 0xFFFFFF;
    }
    //if (c >= 0.5) {lozenges[k].tint = `0x00${colhex}${colhex}`;};
  }

}

function randomize_color() {
  const color1 = Math.random() * 0xFFFFFF;
  const color2 = Math.random() * 0xFFFFFF;
  const color3 = Math.random() * 0xFFFFFF;

  let lozenges = app.stage.lozenges;

  for (let k=0, len=lozenges.length; k<len; k++) {
    const type = lozenges[k].type;
    switch (type) {
      case 1:
        lozenges[k].tint = color1;
        break;
      case 2:
        lozenges[k].tint = color2;
        break;
      case 3:
        lozenges[k].tint = color3;
        break;
    }
  }
}


function default_color() {
  const color1 = 0x1cff00;
  const color2 = 0xfc0606;
  const color3 = 0x0555db;

  let lozenges = app.stage.lozenges;

  for (let k=0, len=lozenges.length; k<len; k++) {
    const type = lozenges[k].type;
    switch (type) {
      case 1:
        lozenges[k].tint = color1;
        break;
      case 2:
        lozenges[k].tint = color2;
        break;
      case 3:
        lozenges[k].tint = color3;
        break;
    }
  }
}

function pause() {
  // toggle start / stop
  PIXI.Ticker.shared.stop();
  /*
  if (!PIXI.Ticker.shared.started) {
    PIXI.Ticker.shared.start();
  } else {
    PIXI.Ticker.shared.stop();
  }
  */
}

function rotate() {
  let container = app.stage.children[0];
  if (container.rotation == 0) {
    container.rotation = Math.PI/6;
    app.stage.rotated = Math.PI/6;
  } else {
    container.rotation = 0;
    app.stage.rotated = 0;
  }
}

function edges() {
  Hexagon.lineThickness = document.getElementById("edges").checked;
}

function paths() {
  Hexagon.paths = document.getElementById("paths").checked;
}

function myFunction() {
  app.stage.children = [];

  document.getElementById("holeNum").value = "0";
  Hexagon.holes = 0;

  let div = document.getElementById("holes");
  div.innerHTML = '';
  setup();
}

// change!!!
function regularHex() {
  // constants for the size of the hexagon
  const N = document.getElementById("Nbox").valueAsNumber;

  // set A,B,C
  document.getElementById("Abox").setAttribute("value", N);
  document.getElementById("Bbox").setAttribute("value", N);
  document.getElementById("Cbox").setAttribute("value", N);
}


function reweight() {
  pause()
  default_color();
  if (!document.getElementById("autorefresh").checked) {
    return;
  }

  const A = document.getElementById("Abox").valueAsNumber;
  const B = document.getElementById("Bbox").valueAsNumber;
  const C = document.getElementById("Cbox").valueAsNumber;

  // get the weight
  const wtype = document.getElementById("wtype").value;
  const cweight = document.getElementById("cweight").valueAsNumber;
  W = weight_hexagon(choose_weight(wtype, cweight, (C+B+1)),1,A,B,C)

  // add the holes
  W.holes = [];
  for (let i=0; i<W.length; i++) {
    W.holes[i] = [];
    W.holes[i].length = W.length;
    W.holes[i].fill(0);
  }

  // add holes to W
  for (let i=0;i<Hexagon.holes;i++) {
    const width = document.getElementById(`holeW${i}`).valueAsNumber;
    const X = document.getElementById(`holeX${i}`).valueAsNumber;
    const Y = document.getElementById(`holeY${i}`).valueAsNumber;
    const type = document.getElementById(`holeType${i}`).valueAsNumber;
    W = gap(W,A,B,C,width,X,Y,type);
  }

  //W = W_split(W);
  //P = Reduction(W, W.im);
  P = Reduction(W);
  let M = Matching(P, W[0].length);

  drawHexagon( M, W.holes);
}


function onDown(e) {
  this.data = e.data;
  this.dragging = true;
}

function onDragMove(e)
{

	if (this.dragging)
    {
      var newPosition = this.data.getLocalPosition(this.parent);
      const r = Hexagon.r;

      const xscale = 2*r*Math.sqrt(3);
      const yscale = 2*r;
      const x = Math.round(newPosition.x/(xscale));
      const y = Math.round((newPosition.y)/(yscale));

      this.position.x = x*xscale;
      this.position.y = y*yscale;

      const num = this.number;
      // this.Xinput.setAttribute("value", 2*x)
      // this.Yinput.setAttribute("value", -2*y)
      // document.getElementById(`holeX${num}`).setAttribute("value", x);
      // document.getElementById(`holeY${num}`).setAttribute("value", -y);
      // jumps double step
      document.getElementById(`holeX${num}`).setAttribute("value", 2*x);
      document.getElementById(`holeY${num}`).setAttribute("value", -y);
    }

}

function onDragEnd()
{
    this.dragging = false;
    // const A = document.getElementById("Abox").valueAsNumber;
    // const B = document.getElementById("Bbox").valueAsNumber;
    // const C = document.getElementById("Cbox").valueAsNumber;

    // get number of circle and get width
    const num = this.number;
    const width = document.getElementById(`holeW${num}`).valueAsNumber

    if (width > 0) {
      reweight()
    }
    // set the interaction data to null
    this.data = null;
}

function hole(container, num) {
  // all the vertices
  let vertex = new PIXI.Graphics();
  vertex.interactive = true;
  vertex.buttonMode = true;
  vertex.beginFill(0x000000);
  vertex.on('mousedown', onDown)
      .on('mousemove', onDragMove)
      .on('mouseup', onDragEnd)
      .on('mouseupoutside', onDragEnd);
      // .on('mouseup', onRelease)
      // .on('mouseupoutside',onRelease);
  vertex.drawCircle(0, 0, 5);
  vertex.endFill();
  vertex.x = -Hexagon.r/2;
  vertex.y = Hexagon.r*Math.sqrt(3)/2;


  const A = document.getElementById("Abox").valueAsNumber;
  const B = document.getElementById("Bbox").valueAsNumber;
  const C = document.getElementById("Cbox").valueAsNumber;
  const max = Math.min(A+B,A+C)/2;

  // make title
  let div = document.getElementById("holes");
  div.innerHTML += `<h2> Hole ${num+1} </h2>`

  let buttongroup = document.createElement("DIV");

  //document.body.appendChild(title)

  buttongroup.innerHTML += `<h3>Width<h3>`;
  let Iwidth = document.createElement("INPUT");
  Iwidth.setAttribute("type", "range");
  Iwidth.setAttribute("value", 0);
  Iwidth.setAttribute("id", `holeW${num}`);
  Iwidth.setAttribute("step", "2");
  Iwidth.setAttribute("min", "0");
  Iwidth.setAttribute("max", `${max}`);
  Iwidth.setAttribute("onchange", "reweight()")
  buttongroup.appendChild(Iwidth);


  buttongroup.innerHTML += `<h3>(X,Y) position<h3>`;
  let Ix = document.createElement("INPUT");
  Ix.setAttribute("type", "number");
  Ix.setAttribute("value", 0);
  Ix.setAttribute("id", `holeX${num}`);
  Ix.setAttribute("onchange", "reweight()")
  Ix.setAttribute("class", "numinput");
  buttongroup.appendChild(Ix);


  //buttongroup.innerHTML += `<h3>Y-pos<h3>`;
  let Iy = document.createElement("INPUT");
  Iy.setAttribute("type", "number");
  Iy.setAttribute("value", 0);
  Iy.setAttribute("id", `holeY${num}`);
  Iy.setAttribute("onchange", "reweight()");
  Iy.setAttribute("class", "numinput");
  buttongroup.appendChild(Iy);

  buttongroup.innerHTML += `<h3>Type<h3> `;
  let Itype = document.createElement("INPUT");
  Itype.setAttribute("type", "number");
  Itype.setAttribute("value", 1);
  Itype.setAttribute("min", 1);
  Itype.setAttribute("max", 3);
  Itype.setAttribute("step", 1);
  Itype.setAttribute("id", `holeType${num}`);
  Itype.setAttribute("onchange", "reweight()");
  Itype.setAttribute("class", "numinput");
  buttongroup.appendChild(Itype);

  div.appendChild(buttongroup);

  vertex.number = num;

  container.addChild(vertex);
}

function addHoles() {
  let div = document.getElementById("holes");
  div.innerHTML = '';
  if (app.stage.children.length > 1) {
  app.stage.removeChildAt(1);
  }

  Hexagon.holes = document.getElementById("holeNum").valueAsNumber;

  let container = new PIXI.Container();
  app.stage.addChild(container);


  for (let i=0; i<Hexagon.holes; i++) {
    hole(container, i);
  }

  container.x = app.screen.width/2;
  container.y = app.screen.height/2;
  //reweight();
}


function qweight(N, a) {
  let bottom;
  let top;
  if (a == 0) {
    bottom = [1];
    top = [1];
  } else {
    const q = Math.exp(-a/N);
    top = new Array(N);
    top.fill(1);
    bottom = new Array(N);
    for (let k=0;k<N;k++) {
      bottom[k] = q**k;
    }
  }
  return [bottom, top];
}

function choose_weight(type, a=0, N=1) {
  let weight;
  const A = document.getElementById("Abox").valueAsNumber;
  const B = document.getElementById("Bbox").valueAsNumber;
  const C = document.getElementById("Cbox").valueAsNumber;
  const kappa = document.getElementById("kappa").valueAsNumber;
  if (type == "uniform") {
    weight = [[1],[1]];
  } else if (type == "qvolume") {
    const q = Math.exp(-a/N);
    // make array
    let bottom = new Array(N);
    bottom.fill(1);
    let top = new Array(N);
    for (let k=0;k<N;k++) {
      top[k] = q**k;
    }
    weight = [top, bottom];
  } else if (type == "periodic1x2") {
    weight = [[1, 1], [a, 1]];
  } else if (type == "periodic2x2") {
    weight = [[a, 1], [1, 1], [1, a], [1, a**2]];
  } else if (type == "periodic2x3") {
    weight = [[a,1,1], [a,1,1], [1,1,a], [1,1,a]];
  } else if (type == "qracah") {
    const q = Math.exp(-a/N);
    // make array
    let bottom = new Array(N);
    bottom.fill(1);
    let top = new Array(N);
    for (let k=0;k<N;k++) {
      top[k] = kappa*q**k - 1/(kappa*q**k);
    }
    weight = [top, bottom];
  } else if (type == "racah") {
      let bottom = new Array(N);
      bottom.fill(1);
      let top = new Array(N);
      for (let k=0;k<N;k++) {
        top[k] = a + k;
      }
      weight = [top, bottom];
  } else if (type == "trigqracah") {
      const q = Math.exp(-a/N);
      // make array
      let bottom = new Array(N);
      bottom.fill(1);
      let top = new Array(N);
      for (let k=0;k<N;k++) {
        top[k] = kappa*q**k - 1/(kappa*q**k);
      }
      weight = [top, bottom];
  }
  return weight
}


function Array2D(n) {
  let M = [];
  for (let i=0; i<n; i++) {
    const row = new Array(n)
    row.fill(0)
    M.push(row);
  }
  return M;
}

function addtoArray(A,B) {
  const n = A.length;
  const m = A[0].length;

  for (let i=0;i<n;i++) {
    for (let j=0;j<n;j++) {
      A[i][j] += B[i][j];
    }
  }

  return A
}

function addVertices() {
  let vertexcontainer = new PIXI.Container();

  for (let i=0;i<app.stage.vertices.length;i++) {
    vertexcontainer.addChild(app.stage.vertices[i]);
  }

  vertexcontainer.position = app.stage.children[0].position;
  vertexcontainer.rotation = app.stage.children[0].rotation;


  app.stage.addChild(vertexcontainer);
}

function hidewform() {
  const wtype = document.getElementById("wtype").value;


  if (wtype == "uniform") {
    document.getElementById("cweight").style.display = "none";
  } else {
    document.getElementById("cweight").style.display = "inline";
  }
  if (wtype == "qracah") {
    document.getElementById("kappa").style.display = "inline";
    document.getElementById("kappanum").style.display = "inline";
  } else {
    document.getElementById("kappa").style.display = "none";
    document.getElementById("kappanum").style.display = "none";
  }
}

function qracahupdate() {
  const newkappa = document.getElementById("kappa").valueAsNumber;
  document.getElementById("kappanum").setAttribute("value", newkappa);
}


window.reweight = reweight;
window.myFunction = myFunction;
window.regularHex = regularHex;
window.rotate = rotate;
window.edges = edges;
window.refresh = refresh;
window.animatehex = animatehex;
window.prob_color = prob_color;
window.randomize_color = randomize_color;
window.default_color = default_color;
window.pause = pause;
window.gap = gap;
window.paths = paths;
window.addHoles = addHoles;
window.weight_hexagon = weight_hexagon;
window.qweight = qweight;
window.addtoArray = addtoArray;
window.hidewform = hidewform;
window.qracahupdate = qracahupdate;

</script>

</body>
</html>
